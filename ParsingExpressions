Expression Parsing:
Theorem 1:
Each operator reduces two numbers to 1, thus there should always be N-1 operators, no matter the arrangement of brackets. (Piazza said implicit multiplication with ()() will not occur)
(3 + 5)* ( 5 – 1 ) 4 num, 3 op
3+(5*(5-1)) 4 num, 3 op
Exception:
 When “-“ is used as a negative sign
Theorem 2:
No matter how you arrange the brackets, there must ALWAYS be an operator between two numbers

Useful Functions:
Global variables:
bracket = [’(‘,’)’]
ops = [’-‘,’+’,’*’,’/’]
digit = [‘0’,’1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’]
Boolean check(array a,char c)
	For o in a:
		If c==o:
			Return true
	Return false


Int BEDMAS(char c): # returns order of BEDMAS (1 if * or /, 0 if + or -
	For int i = 0, i<len(ops) , i++:
		If c==o:
			Return i/2;
	Return -1 # not an operator
	
#this function looks ahead in a string and returns how many spaces away it is from resolving the current stack of brackets
Int brackClose(String S):
	int stack = 0;
	for int i = 0,i<len(S);i++:
	If S[i] is ‘(’ :
		stack+=1 #Bracket level increased
	If S[i] is ‘)’:
		stack -= 1 #Bracket level decreased
		if stack == 0:
			return i #returns the index at which the entire bracket stack was cleared
	return -1 #something bad happened

#This function strips away the outer brackets of an expression, i.e. "((((((3+4)))))) becomes 3+4
String strip(String S):
	while S[0] =="(" and brackClose(S) == length(S)-1:
		S = S[1:length(S)-2] #inclusive
	return S

•	Step 1:

Fundamental Character check:
S = “some expression here”
B = 0  #bracket counter (integer)
index = 0
For character c in S:
	If (not check(ops,c)) and (not check(digit,c)) and (not check(bracket,c)) and not (c==’ ‘):
		Return Invalid expression
	If c is ‘(’ :
		B+=1 #Bracket level increased
	If c is ‘)’:
		B -= 1 #Bracket level decreased
	
	Index++
End of  Loop
If B != 0: #open brackets, or too many closed brackets (brackets didn’t match)
	Return invalid expression
#First Character checks:
If S[0] is ‘+’,’*’ or ‘/’:
	Return invalid expression
#Last Character Check:
If S[length(s)-1] is ‘-‘,’+’,’*’ or ‘/’:
	Return invalid expression






•	Step 2 function for expression checking:
At this point we assume there was no invalid characters and brackets match.

S = “some expression with valid characters and closed brackets”

boolean expChk(S):
	Boolean O = operator flag, false initially #unresolve operator flag
	Boolean N = number flag, false initially
	Boolean S = space flag, false initially
	Boolean carry = true #used for recursive calls	

	For int i = 0, i < len(S),i++:
		#This code should use the flags to verify current character in relation to what came before it
		If check(ops,S[i]):
			If O and not(S[i]==’-‘): #two operators in a row and not *- , /-,+- or --
				Return false
			N = false; #there is now an operator after the number, so we are ok
			O = true; #operator flag on
			S = false;# dont care about spaces before this point now
				
		else If check(digit,S[i]):
				# if the last thing encountered was a number,with or without brackets and spaces in between,but with no operator in between.
				If  N and S:			
					return false
				If 	O: #last thing was an operator
					O = false #there is now a number after the operator, we are ok
				N = true	#now we want to know if there's an operator after the number
				S = false;# don't care about spaces before this point now
		else if check(bracket,S[i]):
				#Treat the entire bracketed segment as a number
				If  N and S:			
					return false
				If 	O: #last thing was an operator
					O = false #there is now a number after the operator, we are ok
				N = true	#now we want to know if there's an operator after the number
				S = false;# don't care about spaces before this point now
				
				#but evaluate the validity of the bracketed space recursively
				
				int end = brackClose(S[i:length(S)-1]) #calculate the end of the bracket stack
				carry = expChk(S[i:end]) #recursively evaluate the validity of the expression
				#forward the index to the end of the bracketed region
				i = end
		else: #must be a space, turn space flag on
				S = true
	return (true and carry)	

•	Step 3:
(The robustness required for this step is depended on the answer i get for my question 
at https://piazza.com/class/ie61ukjk2cf25y?cid=233)
Now that we finally have a truely valid expression, we can begin parsing it
#Utility Function strips whitespaces and excess brackets
String form(String S):
	Boolean B = false #used for bracket adding
	String result = ""
	if S[0] == '-': #if it starts off with a negative
		B = true
		result += '(' #add bracket open
	for int i = 0; i<length(S);i++:
		if S[i] is ' ':#if space
			result += '' #add nothing
		else if B and i>0 and not check(digit,S[i]):
			result += ')'#close the brackets where the number ends
			result += S[i]
		else:
			result += S[i]
	return strip(result) # might as well get rid of excess brackets here

#This function should be a STATIC METHOD in the expression class and called by the constructor on the left side and right side
which are passed as strings to the constructor

Expression parse(String S):
	S = form(S)
	int opIndex = 0 #Index of the first highest order OP
	int bLevel #we're only interested in operators OUTSIDE of brackets
	#loop through characters
	for int i = 0;i<length(S);i++:
		If S[i] is ‘(’ :
		bLevel +=1 #Bracket level increased
		If S[i] is ‘)’:
		bLevel -= 1 #Bracket level decreased
		#look for OPs
		if bLevel == 0 and check(ops,S[i]):#outside of brackets and found an operator
			if (BEDMAS(S[i]) > BEDMAS[opIndex]): #if the new operator is of higher order
				opIndex = i
	#left side is everything left of the opindex
	ls = S[0:opIndex-1]
	#right side is everything right of the opIndex
	rs = S[opIndex+1:length(S)-1]
	
	#now call the corresponding constructor based on the OPERATOR
	if S[opIndex] == '+':
		return Addition(ls,rs) #or however the constructor is supposed to be called
	else if S[opIndex] == '-':
		return Subtraction(ls,rs) #or however the constructor is supposed to be called
	else if S[opIndex] == '-':
		return Multiplication(ls,rs) #or however the constructor is supposed to be called
	else if S[opIndex] == '-':
		return Division(ls,rs) #or however the constructor is supposed to be called
	
		
